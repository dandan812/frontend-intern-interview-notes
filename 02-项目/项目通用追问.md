 ✅ 你的【Web + Vue 实习 80 题 · 结构总览】
### ✅ 模块 1：JavaScript 必杀（18 题）

1.var let const 区别
	var 具有函数作用域，存在变量提升并初始化为 undefined，可以重复声明，会挂载到 window；
	let 具有块级作用域，存在暂时性死区，不能重复声明，可以重新赋值；
	const 也具有块级作用域，必须初始化，不能重新赋值，但可以修改引用类型的内部属性。
2. 作用域和作用域链
	作用域决定变量的可访问范围，
	而作用域链决定了变量在多层嵌套作用域中按照从内到外逐级查找的访问规则。
3. 闭包是什么？项目中哪里用到了？
  	闭包是指函数可以访问其外部作用域中的变量，即使外部函数已经执行完毕。
   	闭包的本质是作用域链导致外部变量被内部函数引用而无法销毁。
	项目中常用于防抖节流、私有变量封装、事件回调以及 React/Vue 的状态保持。
4. this 的 4 种绑定规则
	默认绑定、隐式绑定、显式绑定和 new 绑定，this 的指向由调用方式决定，
	优先级是 new > 显式 > 隐式 > 默认，
	而箭头函数的 this 由定义时的外层作用域决定，不参与这四种规则。
5. 原型与原型链
	 每个函数都有 prototype，用于存放实例共享的方法
	 每个对象都有 __proto__，指向其构造函数的 prototype
	 访问属性时会沿着 __proto__ 逐级向上查找，形成 原型链
	 原型链的终点是 Object.prototype.__proto__ === nulll
6.new 做了什么？
	①创建一个空对象
	② 将该对象的 __proto__ 指向构造函数的 prototype
	③ 将构造函数中的 this 绑定到该对象并执行
	④ 若构造函数返回对象则返回该对象，否则返回新创建的对象
	✅ return 对象 会 破坏原型链
	✅ instanceof 的判断本质
	✅ this 构造的对象 不一定是最终返回值
7. call / apply / bind 区别
	call、apply、bind 都用于显式绑定 this。
	call 和 apply 会立即执行函数，区别只在于参数形式：
	call 传入的是参数列表，apply 传入的是数组；
	bind 不会立即执行，而是返回一个绑定好 this 的新函数，
	常用于回调、定时器和 this 防丢失场景。
8. 防抖和节流的区别与实现思路
	防抖是指在高频触发事件结束后一段时间才执行一次，常用于搜索输入、表单校验等场景；
	  function debounce(fn, delay) {
  		let timer = null   // 闭包保存定时器
  		return function (...args) {
   		 clearTimeout(timer)
    		timer = setTimeout(() => {
     		 fn.apply(this, args)
  		  }, delay)
 	      }
	}
	节流是指在高频触发过程中按固定时间间隔执行，常用于滚动、拖拽等场景；
	防抖的核心是清除上一次定时器，节流的核心是通过时间戳或定时器控制执行频率。
9. map / filter / reduce 区别
	map 用于对数组每一项做映射转换，返回等长的新数组；
	filter 用于按条件筛选元素，返回符合条件的新数组；
	reduce 用于将数组归并为一个值，常用于求和、统计和数据结构转换。
10. 深拷贝 vs 浅拷贝
	浅拷贝只拷贝对象第一层属性，引用类型拷贝的是地址，
	修改嵌套对象会影响原对象；
	深拷贝会拷贝对象所有层级，修改拷贝对象不影响原对象；
	浅拷贝常用 Object.assign 或扩展运算符，
	深拷贝可用递归或 Lodash 的 cloneDeep，JSON 方法也可但有局限。
11. Promise 三个状态
	Promise 有三种状态：Pending（进行中）、Fulfilled（已完成）和 	Rejected（已拒绝）
	状态只能从 pending 转为 fulfilled 或 rejected，并且一旦改变就不可逆；
	通过 then 获取成功结果，通过 catch 获取失败结果。
12. then 为什么可以链式调用
	then 可以链式调用是因为每次调用 then 时都会返回一个新的 Promise，
	这个新的 Promise 的状态和返回值会决定下一个 then 的输入，
	从而实现连续处理异步结果。
13. async / await 是什么语法糖
	async / await 是基于 Promise 的语法糖，用同步的写法表达异步逻辑，
	async 函数返回 Promise，await 用来等待 Promise 的结果。
14. 宏任务 / 微任务
	宏任务是大的异步任务（如 setTimeout），微任务是高优先级任务（如 Promise.then），
	“定时器 + 事件 + 请求 + 渲染” = 宏任务
	“Promise 相关的，几乎都是微任务”
	执行顺序是：先清空微任务，再执行下一个宏任务。
	Promise.then 属于微任务，setTimeout 属于宏任务，Promise 本身只是一个容器。
	同步 → 微任务 → 宏任务
15. 事件循环机制
	事件循环是 JS 处理同步和异步任务的调度机制
	JS 是单线程，需要事件循环来支持异步非阻塞执行。
	JS 先执行同步代码，然后不断从宏任务队列中取任务执行，
	每执行完一个宏任务，都会立即清空所有微任务，如此循环往复。
16. 隐式类型转换规则
	隐式类型转换是 JS 在运算或比较时，自动把不同类型转成同一种类型再计算的过程。
	隐式类型转换主要发生在 +、比较运算、if 判断中，== 会触发转换，=== 不会。
	转 boolean 时只有 6 个值为 false，其它都为 true。
	项目中推荐统一使用 === 避免隐式转换问题。
	0、空串、null、undefined、NaN、false 为 false，其它都为 true。
	加号最特殊
17. 箭头函数和普通函数区别
	特性				普通函数					箭头函数
	this			动态绑定（取决于调用方式）	静态绑定，继承外层作用域 this
	arguments		有					没有（可以用 rest 参数 ...args 替代）
	new			可以作为构造函数			不能用作构造函数（不能 new）
	super		普通函数中正常				箭头函数中继承外层 this 的 super
	prototype			有							没有

	arguments 是 函数内部的一个类数组对象，用于 存储调用函数时传入的所有参数。
	...args 是 ES6 的剩余参数语法
18. 常见内存泄漏场景
	内存泄漏是指程序中不再使用的内存未被释放
	全局变量、闭包、定时器 / 回调未清、DOM 引用未释放、事件监听未移除。
	JS 有自动垃圾回收机制（GC），通过引用计数或标记清除释放不再使用的对象。


---

### ✅ 模块 2：Vue3 高频核心（20 题｜你最重要）

1. Vue2 和 Vue3 的核心区别
	“Vue3 核心区别 Vue2 是：响应式从 Object.defineProperty 改为 Proxy，
	API 从 选项式 API 增加 组合式 API，性能更优、支持 Tree-shaking，
	多根节点 Fragment、异步组件 Suspense 和 DOM 挂载 Teleport，
	TypeScript 支持更好，生命周期使用 setup + onMounted 等组合函数。”
2. ref vs reactive 区别
	ref 用来包裹基本类型，reactive 用来包裹对象 / 数组。ref 有 .value，reactive 没有。
3. 为什么 ref.value？
	因为原始类型不是对象，Vue 无法直接让它们变成响应式，
	所以 ref 用一个带有 .value 的对象把原始值包起来，通过访问 value 才能触发 getter / setter，从而实现响应式。
4. computed vs watch
	computed 是“算值（有返回值 + 缓存）”，watch 是“做事（无返回值 + 副作用）”。
5. watchEffect 使用场景
	watch 用于精确监听一个或多个数据。
	watchEffect 用于自动跟踪依赖并立即执行。
	watch 适合 old/new 对比，watchEffect 适合副作用逻辑。
6. 组件通信方式有哪些？
	Vue3 组件通信有：
	props、emit、父子中转、Pinia（全局状态）、
	provide/inject、事件总线、ref 获取子组件实例、路由参数、本地存储。
	其中最常用的是：props（父→子）、emit（子→父）和 Pinia（全局状态）。

	provide/inject：祖先 → 后代，多级跨层通信
	事件总线（mitt）：任意组件之间的消息广播
	ref + defineExpose：父组件直接调用子组件方法
7. 父子组件通信怎么做？
	父传子：props
	子传父：emit
	父直接操作子：ref + defineExpose
	跨层级通信：provide/inject
8. 兄弟组件通信怎么做？
	兄弟组件通信 4 种方式：
	① 父组件中转（最标准）
	② mitt 事件总线（轻量简单）
	③ Pinia 全局状态管理（项目最常用）
	④ provide / inject（跨层级，但兄弟也可）
9. 生命周期（Vue3）
	📌 最常用三个（面试必问）
	onMounted
	→ 可操作 DOM，发请求。
	onUnmounted
	→ 清理副作用（定时器、事件）。
	onMounted + watchEffect
	→ 监听 + 初始化。
	setup → onBeforeMount → onMounted → onBeforeUpdate → onUpdated → onBeforeUnmount → onUnmounted
10. v-if vs v-show
	v-if 是真正的条件渲染，DOM 会销毁；v-show 只是 CSS 控制显示隐藏，
	DOM 不会消失。不频繁切换用 v-if，频繁切换用 v-show。
11. v-for 中 key 的作用
	key 用来给列表中的每一项做唯一标识，帮助 Vue 在 diff 时精准判断节点的增删改，
	避免错误复用 DOM，提高渲染性能。不能用 index 做 key，因为 index 会变化，导致状态错乱。
12. nextTick 作用
	nextTick 用于在下一次 DOM 更新循环结束后执行回调。因为 Vue 的更新是异步的，
	修改数据不会立即更新视图。nextTick 能保证获取到最新的 DOM 状态，
	常用于操作 DOM、聚焦输入框、列表更新后的滚动处理。
13. keep-alive 是干什么的
	 keep-alive 是 Vue 内置的缓存组件，用于缓存组件实例，避免频繁销毁和重建，提高性能。
	常用于后台管理系统的多页切换、表单页面状态保持、图表数据避免重复加载。
	被缓存的组件会触发 onActivated/onDeactivated，而不会触发 onMounted/onUnmounted。
14. 组件懒加载怎么做
	Vue3 组件懒加载就是使用动态 import，在路由中写成 component: () => import(...)，
	在组件内部使用 defineAsyncComponent。只有在真正使用组件时才会去加载，提高首屏速度与性能。
15. 路由守卫有哪几种
	全局（beforeEach/beforeResolve/afterEach）、
	路由独享（beforeEnter）、
	组件内（beforeRouteEnter/beforeRouteUpdate/beforeRouteLeave）。
	其中最常用的是 beforeEach，主要用于登录鉴权。
16. 动态路由是什么
	动态路由就是带参数的路由，如 /user/:id。
	访问不同 ID 时都使用同一个组件。
	常用于详情页，并且组件复用时会触发 beforeRouteUpdate。
17. Pinia 和 Vuex 区别
	Pinia 是 Vuex 的替代品，Vue3 官方推荐的状态管理。
	和 Vuex 最大的区别是：Pinia 不需要 mutation，写法简单很多；
	并且 API 更符合 Composition API，TypeScript 支持更好，体积更小。
	Vuex 在 Vue2 时代常用，但 Pinia 在 Vue3 中逐渐成为主流。
18. Pinia 持久化怎么做
	Pinia 的持久化通过 pinia-plugin-persistedstate 插件实现，
	只需要在 store 中添加 persist: true，即可自动把状态持久化到 localStorage，刷新页面不会丢失。
19. Vue3 响应式原理（Proxy）
	Vue3 使用 Proxy 实现响应式，通过拦截对象的 get 和 set 操作来完成依赖收集和更新。
	在 get 时调用 track 收集依赖，在 set 时调用 trigger 触发视图更新。
	相比 Vue2 使用 defineProperty，Proxy 可以监听新增属性、删除属性、数组下标等，性能更好、能力更强
20. 项目中如何做权限控制
	项目的权限控制我一般从三层处理：
	第一是路由守卫层做登录状态校验 + 根据 meta.roles 做路由访问控制；
	第二是菜单层，根据用户的角色动态过滤路由生成侧边栏菜单；
	第三是按钮级权限，通过自定义指令 v-permission 来隐藏没有权限的操作按钮。
	如果是复杂项目，会配合后端返回的权限树进行动态路由生成。
---

### ✅ 模块 3：浏览器 & 网络（14 题）

1. 从输入 URL 到页面展示发生了什么
	输入 URL 后浏览器会先进行 URL 解析、DNS 解析、TCP 建连（HTTPS 包含 TLS），然后发送 HTTP 请求。
	服务器返回 HTML 后浏览器构建 DOM、CSSOM，生成渲染树，经过布局、绘制和合成后显示页面，最后断开连接。
2. HTTP 和 HTTPS 区别
3. GET 和 POST 的区别
4. 常见状态码：200 / 301 / 404 / 500
5. 什么是跨域
6. 跨域的解决方案（CORS）
7. Cookie / localStorage / sessionStorage 区别
8. Token 登录流程
9. 前后端分离登录流程
10. 浏览器缓存机制
11. 强缓存 / 协商缓存
12. XSS 是什么，如何防御
13. CSRF 是什么
14. 前端如何保持登录态

---

### ✅ 模块 4：CSS + 响应式（12 题）

1. Flex 常用属性
2. Grid 适合什么场景
3. BFC 是什么
4. 水平垂直居中方案
5. 响应式布局怎么做
6. px / rem / vw 区别
7. 盒模型
8. margin 塌陷
9. position 定位区别
10. overflow 原理
11. display 常见值
12. SCSS 的优势

---

### ✅ 模块 5：工程化 + 工具（8 题）

1. Vite 和 Webpack 区别
2. npm 和 pnpm 区别
3. Git 常用命令
4. Git 分支开发流程
5. 代码规范怎么做
6. Axios 二次封装思路
7. 接口错误统一处理方式
8. 前端如何做环境区分（dev / prod）

---

### ✅ 模块 6：项目实战（8 题｜你最容易拿高分）

1. 你的项目最大难点是什么
2. 电商项目最复杂的模块是哪个
3. 项目中如何做性能优化
4. 图片懒加载怎么实现
5. 为什么要封装组件
6. Pinia 在项目中的设计思路
7. Token 存在哪里最安全
8. 如果让你重构项目，你会怎么做